{"mappings":"ACAA,MAAM,EAAO,SAAS,aAAA,CAAc,SAClB,SAAS,gBAAA,CAAiB,cACzB,SAAS,aAAA,CAAc,gBAE1C,IAAI,EAAe,EACf,EAAc,EAElB,MAAM,EAAiB,AAAC,IACtB,IAAM,EAAa,EAAI,MAAA,CAAO,qBAA9B,GACM,EAAS,CACb,EAAG,EAAI,KAAA,CAAQ,EAAW,IAA1B,CACA,EAAG,EAAI,KAAA,CAAQ,EAAW,GAA1B,AACF,EACA,OAAO,CACT,EAEM,EAA2B,AAAC,IAChC,IAAM,EAAO,EAAG,qBAAhB,GACA,MAAQ,AAAA,CAAA,EAAK,MAAA,CAAS,EAAK,GAAE,AAAF,EAAO,CACpC,EAwFA,SAAS,EAAO,CAAM,EACpB,EAAE,CAAC,KAAA,CAAM,IAAA,CAAK,EAAO,QAAA,EAAU,OAAA,CAAQ,SAAU,CAAM,CAAE,CAAK,EAC5D,EAAO,SAAA,CAAY,CAAA,EACnB,IAAI,EAAO,SAEP,EAAO,SAAA,CAAU,QAAA,CAAS,WAC5B,EAAO,SACP,KAEA,IAEG,EAAO,QAAA,CAAS,MAAA,CAKnB,EAAO,SAAA,CAAY,CAAC,EAAE,EAAK,EAAE,EAC3B,AAAS,WAAT,EAAoB,EAAc,EACnC,QAAQ,EAAE,EAAO,QAAQ,CAAC,EAAE,CAAC,SAAA,CAAU,OAAO,CAAC,CANhD,EAAO,SAAA,CAAY,CAAC,EAAE,EAAK,EAAE,EAC3B,AAAS,WAAT,EAAoB,EAAc,EACnC,QAAQ,EAAE,EAAO,SAAA,CAAU,OAAO,CAAC,AAMxC,EACF,EAEA,QAAQ;AA1FR,SAAkB,CAAM,CAAE,CAAQ,EAChC,IAAI,CAKJ,oCAAmC;AACnC,SAAS,EAAY,CAAG,EACtB,EAAI,cAAJ,GACA,EAAI,YAAA,CAAa,UAAA,CAAa,OAE9B,IAAI,EAAS,EAAI,MAAjB,CACA,GAAI,GAAU,IAAW,GAAU,AAAmB,OAAnB,EAAO,QAAA,CAAmB,CAC3D,UAAU;AACV,IAAM,EAAS,EAAe,GACxB,EAAU,EAAyB,EAAI,MAA7C,CAEI,CAAA,EAAO,CAAA,CAAI,EACT,EAAO,WAAA,CAAY,aAAA,GAAkB,GACvC,EAAO,YAAA,CAAa,EAAQ,EAAO,WADrC,EAKI,EAAO,aAAA,GAAkB,GAC3B,EAAO,YAAA,CAAa,EAAQ,EAIlC,CACF,CAEA,iBAAiB;AACjB,SAAS,EAAW,CAAG,EACrB,EAAI,cAAJ,GAEA,EAAO,SAAA,CAAU,MAAA,CAAO,SACxB,EAAO,mBAAA,CAAoB,WAAY,EAAa,CAAA,GACpD,EAAO,mBAAA,CAAoB,UAAW,EAAY,CAAA,GAElD,wCAAwC;AACxC,EAAS,EACX,CAtCA,8BAA8B;AAC9B,EAAO,GAuCP,iBAAiB;AACjB,EAAO,gBAAA,CACL,YACA,SAAU,CAAG,EACX,EAAS,EAAI,MAAA,CAEb,6BAA6B;AAC7B,EAAI,YAAA,CAAa,aAAA,CAAgB,OACjC,EAAI,YAAA,CAAa,OAAA,CAAQ,OAAQ,EAAO,WAAxC,EAEA,mCAAmC;AACnC,EAAO,gBAAA,CAAiB,WAAY,EAAa,CAAA,GACjD,EAAO,gBAAA,CAAiB,UAAW,EAAY,CAAA,GAE/C,WAAW,WACT,uDAAuD;AACvD,0CAA0C;AAC1C,EAAO,SAAA,CAAU,GAAA,CAAI,QACvB,EAAG,EACL,EACA,CAAA,EAEJ,EA0BS,EAAM,SAAU,CAAI,EAC3B,EAAe,EACf,EAAc,EAEd,EAAO,EACT,E,4D","sources":["<anon>","js/script.js"],"sourcesContent":["const list = document.querySelector(\".list\");\nconst listItems = document.querySelectorAll(\".list-item\");\nconst listHidden = document.querySelector(\".list-hidden\");\nlet lessionIndex = 0;\nlet moduleIndex = 0;\nconst getMouseOffset = (evt)=>{\n    const targetRect = evt.target.getBoundingClientRect();\n    const offset = {\n        x: evt.pageX - targetRect.left,\n        y: evt.pageY - targetRect.top\n    };\n    return offset;\n};\nconst getElementVerticalCenter = (el)=>{\n    const rect = el.getBoundingClientRect();\n    return (rect.bottom - rect.top) / 2;\n};\nconst appendPlaceholder = (evt, idx)=>{\n    evt.preventDefault();\n    if (idx === dragIndex) return;\n    const offset = getMouseOffset(evt);\n    const middleY = getElementVerticalCenter(evt.target);\n    const placeholder = list.children[dragIndex];\n    // console.log(`hover on ${idx} ${offset.y > middleY ? 'bottom half' : 'top half'}`)\n    if (offset.y > middleY) list.insertBefore(evt.target, placeholder);\n    else if (list.children[idx + 1]) list.insertBefore(evt.target.nextSibling || evt.target, placeholder);\n    return;\n};\nfunction sortable(rootEl, onUpdate) {\n    var dragEl;\n    // Making all siblings movable\n    render(rootEl);\n    // Function responsible for sorting\n    function _onDragOver(evt) {\n        evt.preventDefault();\n        evt.dataTransfer.dropEffect = \"move\";\n        var target = evt.target;\n        if (target && target !== dragEl && target.nodeName == \"DIV\") {\n            // Sorting\n            const offset = getMouseOffset(evt);\n            const middleY = getElementVerticalCenter(evt.target);\n            if (offset.y > middleY) {\n                if (target.nextSibling.parentElement === rootEl) rootEl.insertBefore(dragEl, target.nextSibling);\n            //   rootEl.dataset.index = target.nextSibling.dataset.index;\n            } else if (target.parentElement === rootEl) rootEl.insertBefore(dragEl, target);\n        }\n    }\n    // End of sorting\n    function _onDragEnd(evt) {\n        evt.preventDefault();\n        dragEl.classList.remove(\"ghost\");\n        rootEl.removeEventListener(\"dragover\", _onDragOver, false);\n        rootEl.removeEventListener(\"dragend\", _onDragEnd, false);\n        // Notification about the end of sorting\n        onUpdate(dragEl);\n    }\n    // Sorting starts\n    rootEl.addEventListener(\"dragstart\", function(evt) {\n        dragEl = evt.target; // Remembering an element that will be moved\n        // Limiting the movement type\n        evt.dataTransfer.effectAllowed = \"move\";\n        evt.dataTransfer.setData(\"Text\", dragEl.textContent);\n        // Subscribing to the events at dnd\n        rootEl.addEventListener(\"dragover\", _onDragOver, false);\n        rootEl.addEventListener(\"dragend\", _onDragEnd, false);\n        setTimeout(function() {\n            // If this action is performed without setTimeout, then\n            // the moved object will be of this class.\n            dragEl.classList.add(\"ghost\");\n        }, 0);\n    }, false);\n}\nfunction render(rootEl) {\n    [].slice.call(rootEl.children).forEach(function(itemEl, index) {\n        itemEl.draggable = true;\n        let type = \"B\\xe0i\";\n        if (itemEl.classList.contains(\"active\")) {\n            type = \"Module\";\n            moduleIndex++;\n        } else lessionIndex++;\n        if (!itemEl.children.length) itemEl.innerHTML = `${type}: ${type === \"Module\" ? moduleIndex : lessionIndex}: <span>${itemEl.innerText}</span>`;\n        else itemEl.innerHTML = `${type}: ${type === \"Module\" ? moduleIndex : lessionIndex}: <span>${itemEl.children[0].innerText}</span>`;\n    });\n}\n// Using\nsortable(list, function(item) {\n    lessionIndex = 0;\n    moduleIndex = 0;\n    render(list);\n});\n\n//# sourceMappingURL=index.151545d8.js.map\n","const list = document.querySelector(\".list\");\r\nconst listItems = document.querySelectorAll(\".list-item\");\r\nconst listHidden = document.querySelector(\".list-hidden\");\r\n\r\nlet lessionIndex = 0;\r\nlet moduleIndex = 0;\r\n\r\nconst getMouseOffset = (evt) => {\r\n  const targetRect = evt.target.getBoundingClientRect();\r\n  const offset = {\r\n    x: evt.pageX - targetRect.left,\r\n    y: evt.pageY - targetRect.top,\r\n  };\r\n  return offset;\r\n};\r\n\r\nconst getElementVerticalCenter = (el) => {\r\n  const rect = el.getBoundingClientRect();\r\n  return (rect.bottom - rect.top) / 2;\r\n};\r\n\r\nconst appendPlaceholder = (evt, idx) => {\r\n  evt.preventDefault();\r\n  if (idx === dragIndex) {\r\n    return;\r\n  }\r\n\r\n  const offset = getMouseOffset(evt);\r\n  const middleY = getElementVerticalCenter(evt.target);\r\n  const placeholder = list.children[dragIndex];\r\n\r\n  // console.log(`hover on ${idx} ${offset.y > middleY ? 'bottom half' : 'top half'}`)\r\n  if (offset.y > middleY) {\r\n    list.insertBefore(evt.target, placeholder);\r\n  } else if (list.children[idx + 1]) {\r\n    list.insertBefore(evt.target.nextSibling || evt.target, placeholder);\r\n  }\r\n  return;\r\n};\r\n\r\nfunction sortable(rootEl, onUpdate) {\r\n  var dragEl;\r\n\r\n  // Making all siblings movable\r\n  render(rootEl);\r\n\r\n  // Function responsible for sorting\r\n  function _onDragOver(evt) {\r\n    evt.preventDefault();\r\n    evt.dataTransfer.dropEffect = \"move\";\r\n\r\n    var target = evt.target;\r\n    if (target && target !== dragEl && target.nodeName == \"DIV\") {\r\n      // Sorting\r\n      const offset = getMouseOffset(evt);\r\n      const middleY = getElementVerticalCenter(evt.target);\r\n\r\n      if (offset.y > middleY) {\r\n        if (target.nextSibling.parentElement === rootEl) {\r\n          rootEl.insertBefore(dragEl, target.nextSibling);\r\n          //   rootEl.dataset.index = target.nextSibling.dataset.index;\r\n        }\r\n      } else {\r\n        if (target.parentElement === rootEl) {\r\n          rootEl.insertBefore(dragEl, target);\r\n          //   rootEl.dataset.index = target.dataset.index;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // End of sorting\r\n  function _onDragEnd(evt) {\r\n    evt.preventDefault();\r\n\r\n    dragEl.classList.remove(\"ghost\");\r\n    rootEl.removeEventListener(\"dragover\", _onDragOver, false);\r\n    rootEl.removeEventListener(\"dragend\", _onDragEnd, false);\r\n\r\n    // Notification about the end of sorting\r\n    onUpdate(dragEl);\r\n  }\r\n\r\n  // Sorting starts\r\n  rootEl.addEventListener(\r\n    \"dragstart\",\r\n    function (evt) {\r\n      dragEl = evt.target; // Remembering an element that will be moved\r\n\r\n      // Limiting the movement type\r\n      evt.dataTransfer.effectAllowed = \"move\";\r\n      evt.dataTransfer.setData(\"Text\", dragEl.textContent);\r\n\r\n      // Subscribing to the events at dnd\r\n      rootEl.addEventListener(\"dragover\", _onDragOver, false);\r\n      rootEl.addEventListener(\"dragend\", _onDragEnd, false);\r\n\r\n      setTimeout(function () {\r\n        // If this action is performed without setTimeout, then\r\n        // the moved object will be of this class.\r\n        dragEl.classList.add(\"ghost\");\r\n      }, 0);\r\n    },\r\n    false,\r\n  );\r\n}\r\n\r\nfunction render(rootEl) {\r\n  [].slice.call(rootEl.children).forEach(function (itemEl, index) {\r\n    itemEl.draggable = true;\r\n    let type = \"BÃ i\";\r\n\r\n    if (itemEl.classList.contains(\"active\")) {\r\n      type = \"Module\";\r\n      moduleIndex++;\r\n    } else {\r\n      lessionIndex++;\r\n    }\r\n    if (!itemEl.children.length) {\r\n      itemEl.innerHTML = `${type}: ${\r\n        type === \"Module\" ? moduleIndex : lessionIndex\r\n      }: <span>${itemEl.innerText}</span>`;\r\n    } else {\r\n      itemEl.innerHTML = `${type}: ${\r\n        type === \"Module\" ? moduleIndex : lessionIndex\r\n      }: <span>${itemEl.children[0].innerText}</span>`;\r\n    }\r\n  });\r\n}\r\n\r\n// Using\r\nsortable(list, function (item) {\r\n  lessionIndex = 0;\r\n  moduleIndex = 0;\r\n\r\n  render(list);\r\n});\r\n"],"names":["list","document","querySelector","querySelectorAll","lessionIndex","moduleIndex","getMouseOffset","evt","targetRect","target","getBoundingClientRect","offset","x","pageX","left","y","pageY","top","getElementVerticalCenter","el","rect","bottom","render","rootEl","slice","call","children","forEach","itemEl","index","draggable","type","classList","contains","length","innerHTML","innerText","onUpdate","dragEl","_onDragOver","preventDefault","dataTransfer","dropEffect","nodeName","middleY","nextSibling","parentElement","insertBefore","_onDragEnd","remove","removeEventListener","addEventListener","effectAllowed","setData","textContent","setTimeout","add","item"],"version":3,"file":"index.151545d8.js.map"}